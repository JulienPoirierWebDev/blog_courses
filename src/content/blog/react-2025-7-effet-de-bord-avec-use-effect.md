---
author: Julien POIRIER
pubDatetime: 2025-02-06T07:00:00.00Z
modDatetime: 2025-02-06T07:00:00.00Z
title: Ajouter un effet de bord avec useEffect
slug: ajouter-un-effet-de-bord-avec-use-effect
featured: true
draft: false
tags:
  - react
  - debutant
description: L'ajout d'effets de bord dans React permet d'interagir avec l'ext√©rieur de la page (a utiliser avec pr√©caution)
---

# **Comprendre `useEffect` en React : G√©rer les Effets Secondaires et les Requ√™tes API**

Apr√®s avoir explor√© la gestion du **state** et compris comment React met √† jour l‚Äôinterface via l‚Äô**arbre de composants**, il est temps d‚Äôaborder un concept fondamental : **les effets secondaires**.

En React, la fonction `useEffect` est l‚Äôoutil principal pour g√©rer ces effets secondaires, comme :

- üì° **Faire des requ√™tes API**
- ‚è±Ô∏è **D√©marrer des timers**
- üé® **Manipuler directement le DOM**
- üßπ **Nettoyer des ressources quand un composant est supprim√©**

Dans cet article, nous allons :  
‚úÖ **Comprendre ce qu‚Äôest un effet secondaire en React**  
‚úÖ **D√©couvrir comment utiliser `useEffect` pour g√©rer des actions apr√®s le rendu**  
‚úÖ **Faire des requ√™tes API avec `useEffect`**  
‚úÖ **Apprendre √† nettoyer correctement les effets pour √©viter les fuites de m√©moire**

---

## **1. Qu‚Äôest-ce qu‚Äôun Effet Secondaire en React ?**

Un **effet secondaire** (ou **side effect**) correspond √† **toute action qui interagit avec l‚Äôext√©rieur de ton composant** ou qui n‚Äôest pas purement li√©e au rendu de l‚Äôinterface.

### **üìå Exemples d‚Äôeffets secondaires :**

- Faire un appel r√©seau pour r√©cup√©rer des donn√©es (ex : requ√™te API).
- Manipuler le DOM directement (ajouter des classes, des animations).
- D√©marrer ou arr√™ter des timers (`setTimeout`, `setInterval`).
- √âcouter des √©v√©nements globaux (ex : √©coute de la taille de la fen√™tre).

### **Pourquoi a-t-on besoin de `useEffect` ?**

React est con√ßu pour **g√©rer uniquement l‚Äôinterface** de mani√®re d√©clarative. Mais pour int√©grer des actions ext√©rieures (comme une requ√™te API), il faut un moyen de dire √† React **"Fais √ßa apr√®s le rendu"**. C‚Äôest l√† que `useEffect` entre en jeu.

---

## **2. La Syntaxe de `useEffect`**

`useEffect` est un **hook** qui permet de d√©clencher une fonction apr√®s que le composant a √©t√© mont√© (rendu) ou apr√®s que certaines valeurs ont chang√©.

### **üìå Syntaxe de base :**

```jsx
import React, { useEffect } from "react";

useEffect(() => {
  // Code de l‚Äôeffet secondaire
});
```

Par d√©faut, le code dans `useEffect` s‚Äôex√©cute :

1. **Apr√®s le premier rendu** du composant.
2. **Apr√®s chaque mise √† jour** du composant.

---

## **3. Exemple Simple : Mettre √† Jour le Titre de la Page**

Commen√ßons par un exemple simple o√π l‚Äôon change le titre de la page en fonction d‚Äôun compteur.

```jsx
import React, { useState, useEffect } from "react";

function Counter() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    document.title = `Compteur : ${count}`;
  });

  return (
    <div>
      <h1>Compteur : {count}</h1>
      <button onClick={() => setCount(count + 1)}>Incr√©menter</button>
    </div>
  );
}

export default Counter;
```

### **üîç Ce qui se passe :**

1. Lors du **premier rendu**, `useEffect` change le titre de la page en "Compteur : 0".
2. Chaque fois que tu cliques sur le bouton, `count` augmente et **le composant est r√©ex√©cut√©**.
3. Apr√®s chaque mise √† jour, **`useEffect` est d√©clench√© √† nouveau** pour mettre √† jour le titre de la page.

---

## **4. Limiter les Ex√©cutions avec le Tableau de D√©pendances**

Dans l‚Äôexemple pr√©c√©dent, `useEffect` s‚Äôex√©cute **√† chaque rendu**, m√™me si le changement ne concerne pas le titre de la page. Ce n‚Äôest pas toujours n√©cessaire !

### **üìå Comment limiter les ex√©cutions ?**

On peut ajouter un **tableau de d√©pendances** pour dire √† React :

- **Quand** ex√©cuter l‚Äôeffet.
- **Quels changements** doivent d√©clencher l‚Äôeffet.

### **Exemple avec d√©pendances :**

```jsx
useEffect(() => {
  document.title = `Compteur : ${count}`;
}, [count]);
```

### **üîç Explication :**

- Le tableau `[count]` indique que l‚Äôeffet doit s‚Äôex√©cuter **uniquement quand `count` change**.
- Si d‚Äôautres √©tats changent dans le composant, l‚Äôeffet **ne sera pas d√©clench√©**.

### **Ex√©cuter l‚Äôeffet une seule fois (au montage) :**

Pour ex√©cuter un effet **une seule fois au montage** du composant (comme `componentDidMount` dans les classes), on passe un **tableau vide** :

```jsx
useEffect(() => {
  console.log("Le composant est mont√© !");
}, []);
```

---

## **5. Faire des Requ√™tes API avec `useEffect`**

L‚Äôun des usages les plus courants de `useEffect` est de **faire des appels r√©seau** pour r√©cup√©rer des donn√©es.

### **üìå Exemple : R√©cup√©rer des utilisateurs depuis une API**

Nous allons utiliser l‚ÄôAPI gratuite [JSONPlaceholder](https://jsonplaceholder.typicode.com/) pour r√©cup√©rer une liste d‚Äôutilisateurs.

```jsx
import React, { useState, useEffect } from "react";

function UserList() {
  const [users, setUsers] = useState([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    fetch("https://jsonplaceholder.typicode.com/users")
      .then(response => response.json())
      .then(data => {
        setUsers(data);
        setLoading(false);
      })
      .catch(error => console.error("Erreur :", error));
  }, []);

  if (loading) {
    return <p>Chargement en cours...</p>;
  }

  return (
    <div>
      <h2>Liste des utilisateurs</h2>
      <ul>
        {users.map(user => (
          <li key={user.id}>
            {user.name} ({user.email})
          </li>
        ))}
      </ul>
    </div>
  );
}

export default UserList;
```

### **üîç Explication :**

1. Lors du premier rendu, `useEffect` ex√©cute la requ√™te `fetch`.
2. Quand les donn√©es sont r√©cup√©r√©es, `setUsers(data)` met √† jour le state et d√©clenche un nouveau rendu pour afficher la liste des utilisateurs.
3. Le tableau de d√©pendances `[]` garantit que la requ√™te est **ex√©cut√©e une seule fois**.

---

## **6. Nettoyer les Effets : √âviter les Fuites de M√©moire**

Parfois, un effet secondaire **doit √™tre nettoy√©** pour √©viter des comportements ind√©sirables. Par exemple :

- Arr√™ter un **timer**.
- Supprimer un **√©couteur d‚Äô√©v√©nement**.
- Annuler une **requ√™te en cours** si le composant est d√©mont√©.

### **üìå Exemple : Utiliser un Timer et le Nettoyer**

```jsx
import React, { useState, useEffect } from "react";

function Timer() {
  const [seconds, setSeconds] = useState(0);

  useEffect(() => {
    const interval = setInterval(() => {
      setSeconds(prevSeconds => prevSeconds + 1);
    }, 1000);

    // Nettoyage de l'effet (clearInterval)
    return () => clearInterval(interval);
  }, []);

  return <h1>Temps √©coul√© : {seconds} secondes</h1>;
}

export default Timer;
```

### **üîç Explication :**

1. `setInterval` d√©marre un timer qui incr√©mente `seconds` toutes les secondes.
2. Lorsque le composant est supprim√© (par exemple, en naviguant vers une autre page), le `return () => clearInterval(interval)` **arr√™te le timer** pour √©viter des fuites de m√©moire.

---

## **7. Le Mode Strict de React et `useEffect` : Pourquoi Mon Effet s‚ÄôEx√©cute Deux Fois ?**

Si tu d√©veloppes en React avec la configuration par d√©faut (comme avec **Create React App** ou **Vite**), tu as peut-√™tre remarqu√© que ton effet `useEffect` s‚Äôex√©cute **deux fois** lors du premier rendu. Ce comportement peut sembler d√©routant au d√©but, mais il est en fait li√© au **Mode Strict de React**.

### **üìå Qu‚Äôest-ce que le Mode Strict (`StrictMode`) en React ?**

Le **Mode Strict** de React est un outil de **d√©veloppement** (et uniquement de d√©veloppement) qui aide √† :

- D√©tecter des **probl√®mes potentiels** dans ton application.
- Mettre en avant des **pratiques recommand√©es**.
- **Simuler des comportements** qui pourraient appara√Ætre dans des situations complexes (comme le rendu concurrentiel).

Il s‚Äôactive automatiquement dans les projets cr√©√©s avec Create React App ou Vite et **n‚Äôaffecte pas l‚Äôapplication en production**.

### **Exemple : Comment le Mode Strict est activ√© ?**

Dans le fichier `main.jsx` de ton projet React, tu verras probablement ceci :

```jsx
import React from "react";
import ReactDOM from "react-dom/client";
import App from "./App";

ReactDOM.createRoot(document.getElementById("root")).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
```

### **Que fait le Mode Strict ?**

1. Il **d√©tecte des probl√®mes** comme des effets secondaires inattendus ou des mutations d‚Äô√©tat incorrectes.
2. Il **force la r√©ex√©cution** de certaines fonctions pour t‚Äôaider √† rep√©rer des comportements non s√©curis√©s.

---

## **8. Pourquoi `useEffect` S‚ÄôEx√©cute Deux Fois en Mode Strict ?**

En Mode Strict, React **monte et d√©monte** imm√©diatement les composants **une premi√®re fois**, puis les **remonte** pour d√©tecter des effets secondaires ind√©sirables.

### **üìå Exemple :**

```jsx
import React, { useEffect } from "react";

function DemoEffect() {
  useEffect(() => {
    console.log("useEffect ex√©cut√©");
  }, []);

  return <h1>Regarde la console !</h1>;
}

export default DemoEffect;
```

### **R√©sultat en Mode Strict :**

```
useEffect ex√©cut√©
useEffect ex√©cut√©
```

---

### **üîç Pourquoi React fait √ßa ?**

1. **D√©tection des effets non nettoy√©s** : Si un effet secondaire n‚Äôest pas correctement nettoy√© (par exemple, un timer ou un √©couteur d‚Äô√©v√©nements), ce comportement aide √† identifier des **fuites de m√©moire** potentielles.
2. **Simulation des comportements concurrents** : Avec l‚Äôintroduction de fonctionnalit√©s comme **React Concurrent Mode**, certains composants peuvent √™tre mont√©s/d√©mont√©s rapidement. Le Mode Strict permet de simuler ce genre de situations.

---

## **9. Comment Corriger ou G√©rer ce Comportement ?**

### **1. Nettoyer correctement les effets**

Quand tu utilises des effets qui cr√©ent des ressources (comme des timers, des abonnements √† des √©v√©nements, etc.), il est essentiel de **nettoyer** ces effets avec une fonction de retour.

**Exemple avec un timer :**

```jsx
useEffect(() => {
  const timer = setInterval(() => {
    console.log("Timer en cours...");
  }, 1000);

  // Nettoyage pour √©viter les fuites de m√©moire
  return () => {
    clearInterval(timer);
    console.log("Timer nettoy√©");
  };
}, []);
```

---

### **2. D√©sactiver le Mode Strict (d√©conseill√©)**

Si le double rendu te d√©range pendant le d√©veloppement, tu peux retirer `<React.StrictMode>` dans `main.jsx`. **Cependant, ce n‚Äôest pas recommand√©**, car tu perds les avantages des v√©rifications automatiques de React.

**Avant (Mode Strict activ√©) :**

```jsx
<React.StrictMode>
  <App />
</React.StrictMode>
```

**Apr√®s (Mode Strict d√©sactiv√©) :**

```jsx
<App />
```

---

### **3. Ignorer en Production**

Pas d‚Äôinqui√©tude ! Le **Mode Strict n‚Äôaffecte pas le comportement en production**.  
En production, `useEffect` ne s‚Äôex√©cutera qu‚Äôune seule fois comme attendu.

---

## **10. En R√©sum√© : Le Mode Strict et `useEffect`**

üéØ **Le Mode Strict de React est un outil pr√©cieux pour identifier des probl√®mes potentiels dans ton code.**  
Quand il est activ√© :  
‚úÖ `useEffect` s‚Äôex√©cute **deux fois lors du montage** pour d√©tecter des effets non nettoy√©s.  
‚úÖ Ce comportement **n‚Äôappara√Æt pas en production**.  
‚úÖ Le Mode Strict t‚Äôaide √† anticiper des situations complexes (comme le rendu concurrentiel).

**Nettoie toujours correctement tes effets** pour √©viter des fuites de m√©moire et assurer la stabilit√© de ton application.

---

## **11. Bonnes Pratiques avec `useEffect`**

### **‚úÖ Utilise le tableau de d√©pendances pour contr√¥ler quand l‚Äôeffet s‚Äôex√©cute**

- `[]` : L‚Äôeffet s‚Äôex√©cute **une seule fois** au montage.
- `[stateVar]` : L‚Äôeffet s‚Äôex√©cute **quand `stateVar` change**.

### **‚úÖ Nettoie toujours les effets qui cr√©ent des ressources externes**

- Pour les **timers**, les **√©couteurs d‚Äô√©v√©nements**, ou les **requ√™tes API**, utilise un retour de fonction dans `useEffect` pour faire le m√©nage.

### **‚úÖ √âvite les effets inutiles**

Ne mets pas dans le tableau de d√©pendances des valeurs qui **ne changent pas** ou qui n‚Äôont **pas d‚Äôimpact sur l‚Äôeffet**.

---

## **12. Conclusion : Pourquoi `useEffect` est Essentiel en React**

üéØ **`useEffect` est l‚Äôoutil indispensable pour g√©rer des effets secondaires dans une application React.**  
Avec lui, tu peux :  
‚úÖ Faire des **requ√™tes API** et r√©cup√©rer des donn√©es externes.  
‚úÖ G√©rer des **timers**, des **√©couteurs d‚Äô√©v√©nements**, et des **manipulations du DOM**.  
‚úÖ Nettoyer correctement les ressources pour √©viter des **fuites de m√©moire**.

---

**üöÄ Prochaine √©tape : G√©rer des √©tats plus complexes avec `useReducer` et comprendre quand l‚Äôutiliser √† la place de `useState`.**  
üëâ **Lis l‚Äôarticle suivant : "useState vs useReducer : Quelle diff√©rence et quand les utiliser en React ?"**
