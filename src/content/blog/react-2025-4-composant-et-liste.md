---
author: Julien POIRIER
pubDatetime: 2025-02-06T07:00:00.00Z
modDatetime: 2025-02-06T07:00:00.00Z
title: Comprendre et utiliser .map avec des composants modulaires
slug: composant-map-et-les-listes-en-react
featured: true
draft: false
tags:
  - react
  - debutant
description: Nous verrons comment rapidement mettre une place un projet React avec le tooling de Vite
---

# **Comprendre et Utiliser `.map()` en React : Le Guide Ultime pour les D√©butants**

En React, l‚Äôune des difficult√©s courantes pour les d√©butants est de comprendre **comment afficher une liste d‚Äô√©l√©ments de mani√®re efficace**. C‚Äôest l√† qu‚Äôintervient la m√©thode `.map()`, un outil puissant pour g√©n√©rer dynamiquement des composants √† partir de donn√©es.

Dans cet article, nous allons :

- **D√©finir ce que fait `.map()` en JavaScript et en React**
- **Voir comment l‚Äôutiliser pour afficher des listes dynamiquement**
- **Cr√©er un composant r√©utilisable et modulaire**
- **Explorer un exemple concret avec des cartes de produits**
- **Ajouter une recherche dynamique pour un affichage interactif**

---

## **1. Qu‚Äôest-ce que `.map()` en JavaScript ?**

Avant de l‚Äôutiliser en React, il est important de comprendre le `.map()` en JavaScript natif.

### **D√©finition**

`.map()` est une m√©thode des tableaux en JavaScript qui permet de **transformer chaque √©l√©ment d‚Äôun tableau en appliquant une fonction** et de retourner un **nouveau tableau** contenant les √©l√©ments modifi√©s.

### **Exemple simple en JavaScript**

```js
const nombres = [1, 2, 3, 4, 5];
const doubles = nombres.map(nombre => nombre * 2);
console.log(doubles); // [2, 4, 6, 8, 10]
```

Ici, on applique une fonction qui multiplie chaque nombre par 2. Le tableau `doubles` contient les nouveaux r√©sultats.

---

## **2. `.map()` en React : G√©n√©rer du JSX Dynamique**

React introduit une **particularit√©** : contrairement √† JavaScript o√π `.map()` retourne un tableau de valeurs, **React rend directement un tableau d‚Äô√©l√©ments JSX dans le flux de la page**.

### **Cas sans `.map()` : Code r√©p√©titif**

Imaginons que nous devons afficher une liste d‚Äôutilisateurs.

```jsx
function UserList() {
  return (
    <div>
      <h2>Liste des utilisateurs</h2>
      <p>Utilisateur : Alice</p>
      <p>Utilisateur : Bob</p>
      <p>Utilisateur : Charlie</p>
    </div>
  );
}
```

**Probl√®me** : Ce code est fig√©. Si on a 100 utilisateurs, il devient ing√©rable.

---

## **3. Utiliser `.map()` pour G√©rer des Listes Dynamiques**

Plut√¥t que d‚Äô√©crire chaque √©l√©ment √† la main, nous pouvons **utiliser `.map()`** pour g√©n√©rer automatiquement les balises JSX.

### **Exemple : Affichage d‚Äôune liste d‚Äôutilisateurs**

```jsx
function UserList() {
  const users = ["Alice", "Bob", "Charlie"];

  return (
    <div>
      <h2>Liste des utilisateurs</h2>
      {users.map((user, index) => (
        <p key={index}>Utilisateur : {user}</p>
      ))}
    </div>
  );
}
```

### **Explication**

1. **Le tableau `users` contient la liste des noms.**
2. **`.map()` parcourt chaque √©l√©ment et retourne un `<p>` avec le nom de l‚Äôutilisateur.**
3. **React affiche directement ce tableau d‚Äô√©l√©ments JSX dans le DOM.**

> **üí° Astuce** : L‚Äôattribut `key={index}` est important pour aider React √† optimiser le rendu (nous y reviendrons plus tard).

---

## **4. Extraire un Composant R√©utilisable**

Afficher une simple liste est une bonne premi√®re √©tape, mais nous pouvons aller plus loin en **cr√©ant un composant r√©utilisable**.

### **Cr√©er un Composant `<User />`**

```jsx
function User({ name }) {
  return <p>Utilisateur : {name}</p>;
}

function UserList() {
  const users = ["Alice", "Bob", "Charlie"];

  return (
    <div>
      <h2>Liste des utilisateurs</h2>
      {users.map((user, index) => (
        <User key={index} name={user} />
      ))}
    </div>
  );
}
```

### **Pourquoi faire √ßa ?**

‚úÖ **Modularit√©** : Si demain on veut ajouter une ic√¥ne, un style sp√©cifique, ou d‚Äôautres infos (√¢ge, email...), on modifie uniquement `<User />`.  
‚úÖ **Code plus lisible et maintenable**.

---

## **5. Exemple Concret : Afficher une Liste de Cartes**

Un cas classique en d√©veloppement web est **l‚Äôaffichage d‚Äôune liste de produits sous forme de cartes**.

### **Exercice : Affichage de Produits**

```jsx
function Product({ name, price }) {
  return (
    <div className="product-card">
      <h3>{name}</h3>
      <p>Prix : {price} ‚Ç¨</p>
    </div>
  );
}

function ProductList() {
  const products = [
    { id: 1, name: "Ordinateur", price: 999 },
    { id: 2, name: "Smartphone", price: 499 },
    { id: 3, name: "Casque Audio", price: 199 },
  ];

  return (
    <div>
      <h2>Produits en vente</h2>
      <div className="product-list">
        {products.map(product => (
          <Product key={product.id} name={product.name} price={product.price} />
        ))}
      </div>
    </div>
  );
}
```

### **Pourquoi c‚Äôest utile ?**

‚úîÔ∏è **On manipule des donn√©es dynamiques**  
‚úîÔ∏è **On √©vite la r√©p√©tition manuelle**  
‚úîÔ∏è **On rend le code modulaire et facile √† maintenir**

---

## **6. L‚ÄôImportance de la `key` dans `.map()`**

React utilise les `key` pour **optimiser le rendu** et √©viter les erreurs. Une `key` unique aide React √† identifier **quel √©l√©ment a chang√©, ajout√© ou supprim√©**.

### **Exemple d‚Äôerreur courante**

```jsx
{
  products.map(product => (
    <Product name={product.name} price={product.price} />
  ));
}
```

üö® **React va afficher un warning car il manque `key={product.id}`**.

### **Pourquoi l'index n'est pas une bonne `key` dans `.map()` ?**

Il est tentant d‚Äôutiliser l‚Äô**index du tableau** comme `key` lorsque les objets n‚Äôont pas d‚Äôidentifiant unique. C‚Äôest une solution rapide et facile, mais elle **pose des probl√®mes** dans certaines situations.

#### **1. React et le Re-rendering**

React utilise les `key` pour identifier **de mani√®re unique** chaque √©l√©ment d‚Äôune liste et optimiser son rendu. Si les `key` changent de mani√®re inattendue, React peut :

- **Mal r√©utiliser les composants**, ce qui entra√Æne un affichage incorrect.
- **Supprimer et recr√©er des √©l√©ments inutiles**, ce qui ralentit l‚Äôapplication.

#### **2. L'index change lorsque la liste est modifi√©e**

L‚Äôun des plus gros probl√®mes avec `key={index}` se produit **lorsqu‚Äôun √©l√©ment est ajout√©, supprim√© ou r√©organis√©**.

Exemple :

```jsx
function UserList() {
  const [users, setUsers] = React.useState(["Alice", "Bob", "Charlie"]);

  return (
    <div>
      {users.map((user, index) => (
        <p key={index}>{user}</p>
      ))}
      <button onClick={() => setUsers(["David", ...users])}>
        Ajouter David
      </button>
    </div>
  );
}
```

üö® **Probl√®me** : Si un nouvel √©l√©ment est ins√©r√© au d√©but (`David`), tous les indices suivants sont d√©cal√©s. **React va croire que tous les √©l√©ments ont chang√©**, alors qu‚Äôils n‚Äôont fait que se d√©caler.

#### **3. Mauvaise gestion de l‚Äô√©tat des composants enfants**

Si chaque √©l√©ment de la liste contient un **champ √©ditable ou un √©tat local**, React peut mal le g√©rer si `key={index}` est utilis√©.

Exemple :

```jsx
function EditableList() {
  const [items, setItems] = React.useState(["Item 1", "Item 2", "Item 3"]);

  return (
    <div>
      {items.map((item, index) => (
        <input key={index} defaultValue={item} />
      ))}
      <button onClick={() => setItems(["Nouvel Item", ...items])}>
        Ajouter un item
      </button>
    </div>
  );
}
```

**Bug possible** : En ajoutant un √©l√©ment au d√©but, l‚Äôentr√©e qui √©tait li√©e √† "Item 1" va rester √† la premi√®re place **mais son √©tat interne va suivre l‚Äôancien index**, provoquant un comportement inattendu.

---

## **Bonne Pratique : Utiliser une ID Unique**

La meilleure approche est d‚Äôutiliser un **identifiant unique** pour chaque √©l√©ment.

```jsx
const users = [
  { id: 1, name: "Alice" },
  { id: 2, name: "Bob" },
  { id: 3, name: "Charlie" },
];

{
  users.map(user => <p key={user.id}>{user.name}</p>);
}
```

‚úÖ **Avantages** :

- Pas d‚Äôerreur lors des ajouts/suppressions.
- Meilleure optimisation du rendu par React.
- Meilleure gestion de l‚Äô√©tat interne des composants.

  **√âvite d‚Äôutiliser l‚Äôindex comme `key`**, sauf si la liste est **totalement statique et ne changera jamais**. Pour toutes les autres situations, **pr√©f√©rez une cl√© unique issue des donn√©es**.

---

## **7. BONUS : Ajouter une Recherche Dynamique**

Pour rendre notre liste **interactive**, ajoutons un champ de recherche qui filtre les produits en **temps r√©el**.

### **Exercice : Ajouter un Filtre Dynamique**

```jsx
function ProductList() {
  const [search, setSearch] = React.useState("");
  const products = [
    { id: 1, name: "Ordinateur", price: 999 },
    { id: 2, name: "Smartphone", price: 499 },
    { id: 3, name: "Casque Audio", price: 199 },
  ];

  const filteredProducts = products.filter(product =>
    product.name.toLowerCase().includes(search.toLowerCase())
  );

  return (
    <div>
      <h2>Produits en vente</h2>
      <input
        type="text"
        placeholder="Rechercher un produit..."
        value={search}
        onChange={e => setSearch(e.target.value)}
      />
      <div className="product-list">
        {filteredProducts.map(product => (
          <Product key={product.id} name={product.name} price={product.price} />
        ))}
      </div>
    </div>
  );
}
```

### **Pourquoi c‚Äôest int√©ressant ?**

- On **g√®re les entr√©es utilisateur**
- On **filtre dynamiquement la liste**
- C‚Äôest une **base pour plein de projets interactifs**

---

## **Conclusion**

1. **`.map()` permet de g√©n√©rer dynamiquement du JSX √† partir d‚Äôun tableau.**
2. **React affiche directement un tableau d‚Äô√©l√©ments JSX dans le flux du DOM.**
3. **Extraire un composant rend le code plus propre et r√©utilisable.**
4. **Avec `.map()`, on peut facilement cr√©er des interfaces interactives et modulaires.**
5. **Utiliser une `key` unique est essentiel pour √©viter les bugs et am√©liorer les performances.**

> **üëâ Maintenant, √† toi de jouer !** Essaie d‚Äôafficher une liste d‚Äôarticles de blog avec `.map()`.
